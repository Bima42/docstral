// This file is auto-generated by @hey-api/openapi-ts

import type { Client, Options as Options2, TDataShape } from './client';
import { client } from './client.gen';
import type { CreateChatChatsPostData, CreateChatChatsPostErrors, CreateChatChatsPostResponses, DeleteChatData, DeleteChatErrors, DeleteChatResponses, GetChatByIdData, GetChatByIdErrors, GetChatByIdResponses, HealthGetData, HealthGetResponses, ListChatsData, ListChatsErrors, ListChatsResponses, StreamMessageData, StreamMessageErrors, StreamMessageResponses, UpdateChatData, UpdateChatErrors, UpdateChatResponses, VerifyTokenAuthVerifyPostData, VerifyTokenAuthVerifyPostResponses } from './types.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Get service health status
 */
export const healthGet = <ThrowOnError extends boolean = false>(options?: Options<HealthGetData, ThrowOnError>) => {
	return (options?.client ?? client).get<HealthGetResponses, unknown, ThrowOnError>({
		url: '/health',
		...options
	});
};

/**
 * List chats
 */
export const listChats = <ThrowOnError extends boolean = false>(options?: Options<ListChatsData, ThrowOnError>) => {
	return (options?.client ?? client).get<ListChatsResponses, ListChatsErrors, ThrowOnError>({
		security: [
			{
				scheme: 'bearer',
				type: 'http'
			}
		],
		url: '/chats',
		...options
	});
};

/**
 * Create a new chat
 */
export const createChatChatsPost = <ThrowOnError extends boolean = false>(options: Options<CreateChatChatsPostData, ThrowOnError>) => {
	return (options.client ?? client).post<CreateChatChatsPostResponses, CreateChatChatsPostErrors, ThrowOnError>({
		security: [
			{
				scheme: 'bearer',
				type: 'http'
			}
		],
		url: '/chats',
		...options,
		headers: {
			'Content-Type': 'application/json',
			...options.headers
		}
	});
};

/**
 * Delete a chat
 */
export const deleteChat = <ThrowOnError extends boolean = false>(options: Options<DeleteChatData, ThrowOnError>) => {
	return (options.client ?? client).delete<DeleteChatResponses, DeleteChatErrors, ThrowOnError>({
		security: [
			{
				scheme: 'bearer',
				type: 'http'
			}
		],
		url: '/chat/{chat_id}',
		...options
	});
};

/**
 * Get a chat by ID
 */
export const getChatById = <ThrowOnError extends boolean = false>(options: Options<GetChatByIdData, ThrowOnError>) => {
	return (options.client ?? client).get<GetChatByIdResponses, GetChatByIdErrors, ThrowOnError>({
		security: [
			{
				scheme: 'bearer',
				type: 'http'
			}
		],
		url: '/chat/{chat_id}',
		...options
	});
};

/**
 * Update a chat's title
 */
export const updateChat = <ThrowOnError extends boolean = false>(options: Options<UpdateChatData, ThrowOnError>) => {
	return (options.client ?? client).put<UpdateChatResponses, UpdateChatErrors, ThrowOnError>({
		security: [
			{
				scheme: 'bearer',
				type: 'http'
			}
		],
		url: '/chat/{chat_id}',
		...options,
		headers: {
			'Content-Type': 'application/json',
			...options.headers
		}
	});
};

/**
 * Stream an assistant reply to a user message
 * Stream assistant response with automatic tool call handling.
 *
 * Flow:
 * 1. Save user message
 * 2. Check for tool calls (non-streaming invoke)
 * 3. If tool call: execute retrieval, add context, stream final response
 * 4. If no tool call: stream response directly
 * 5. Save assistant message with usage metrics
 */
export const streamMessage = <ThrowOnError extends boolean = false>(options: Options<StreamMessageData, ThrowOnError>) => {
	return (options.client ?? client).post<StreamMessageResponses, StreamMessageErrors, ThrowOnError>({
		security: [
			{
				scheme: 'bearer',
				type: 'http'
			}
		],
		url: '/chat/{chat_id}/stream',
		...options,
		headers: {
			'Content-Type': 'application/json',
			...options.headers
		}
	});
};

/**
 * Verify token and return the current user
 */
export const verifyTokenAuthVerifyPost = <ThrowOnError extends boolean = false>(options?: Options<VerifyTokenAuthVerifyPostData, ThrowOnError>) => {
	return (options?.client ?? client).post<VerifyTokenAuthVerifyPostResponses, unknown, ThrowOnError>({
		security: [
			{
				scheme: 'bearer',
				type: 'http'
			}
		],
		url: '/auth/verify',
		...options
	});
};
